"use strict";
/*!
This file is part of CycloneDX generator for NPM projects.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

SPDX-License-Identifier: Apache-2.0
Copyright (c) OWASP Foundation. All Rights Reserved.
*/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TreeBuilder = exports.BomBuilder = void 0;
const cyclonedx_library_1 = require("@cyclonedx/cyclonedx-library");
const path = __importStar(require("path"));
const npmRunner_1 = require("./npmRunner");
const properties_1 = require("./properties");
const thisTool_1 = require("./thisTool");
const versionCompare_1 = require("./versionCompare");
class BomBuilder {
    constructor(toolBuilder, componentBuilder, treeBuilder, purlFactory, options, console_) {
        this.hashRE_sha512_base64 = /^sha512-([a-z0-9+/]{86}==)$/i;
        this.resolvedRE_ignore = /^(?:ignore|file):/i;
        this.toolBuilder = toolBuilder;
        this.componentBuilder = componentBuilder;
        this.treeBuilder = treeBuilder;
        this.purlFactory = purlFactory;
        this.ignoreNpmErrors = options.ignoreNpmErrors ?? false;
        this.metaComponentType = options.metaComponentType ?? cyclonedx_library_1.Enums.ComponentType.Library;
        this.packageLockOnly = options.packageLockOnly ?? false;
        this.omitDependencyTypes = new Set(options.omitDependencyTypes ?? []);
        this.reproducible = options.reproducible ?? false;
        this.flattenComponents = options.flattenComponents ?? false;
        this.shortPURLs = options.shortPURLs ?? false;
        this.console = console_;
    }
    buildFromProjectDir(projectDir, process) {
        return this.buildFromNpmLs(this.fetchNpmLs(projectDir, process));
    }
    getNpmVersion(npmRunner, process_) {
        let npmVersion;
        this.console.info('INFO  | detect NPM version ...');
        try {
            npmVersion = npmRunner(['--version'], {
                env: process_.env,
                encoding: 'buffer',
                maxBuffer: Number.MAX_SAFE_INTEGER
            }).toString().split('.').map(v => Number(v));
        }
        catch (runError) {
            this.console.group('DEBUG | npm-ls: STDOUT');
            this.console.debug('%s', runError.stdout);
            this.console.groupEnd();
            this.console.group('WARN  | npm-ls: MESSAGE');
            this.console.warn('%s', runError.message);
            this.console.groupEnd();
            this.console.group('ERROR | npm-ls: STDERR');
            this.console.error('%s', runError.stderr);
            this.console.groupEnd();
            throw runError;
        }
        this.console.debug('DEBUG | detected NPM version %j', npmVersion);
        return npmVersion;
    }
    fetchNpmLs(projectDir, process_) {
        const npmRunner = (0, npmRunner_1.makeNpmRunner)(process_, this.console);
        const npmVersion = this.getNpmVersion(npmRunner, process_);
        const args = [
            'ls',
            '--json',
            '--long',
            npmVersion[0] >= 7
                ? '--all'
                : '--depth=255'
        ];
        if (this.packageLockOnly) {
            if (npmVersion[0] >= 7) {
                args.push('--package-lock-only');
            }
            else {
                this.console.warn('WARN  | your NPM does not support "--package-lock-only", internally skipped this option');
            }
        }
        if ((0, versionCompare_1.versionCompare)(npmVersion, [8, 7]) >= 0) {
            for (const odt of this.omitDependencyTypes) {
                args.push(`--omit=${odt}`);
            }
        }
        else {
            for (const odt of this.omitDependencyTypes) {
                switch (odt) {
                    case 'dev':
                        this.console.warn('WARN  | your NPM does not support "--omit=%s", internally using "--production" to mitigate', odt);
                        args.push('--production');
                        break;
                    case 'peer':
                    case 'optional':
                        this.console.warn('WARN  | your NPM does not support "--omit=%s", internally skipped this option', odt);
                        break;
                }
            }
        }
        this.console.info('INFO  | gather dependency tree ...');
        this.console.debug('DEBUG | npm-ls: run npm with %j in %j', args, projectDir);
        let npmLsReturns;
        try {
            npmLsReturns = npmRunner(args, {
                cwd: projectDir,
                env: process_.env,
                encoding: 'buffer',
                maxBuffer: Number.MAX_SAFE_INTEGER
            });
        }
        catch (runError) {
            this.console.group('WARN  | npm-ls: MESSAGE');
            this.console.warn('%s', runError.message);
            this.console.groupEnd();
            this.console.group('ERROR | npm-ls: STDERR');
            this.console.error('%s', runError.stderr);
            this.console.groupEnd();
            if (!this.ignoreNpmErrors) {
                throw new Error(`npm-ls exited with errors: ${runError.status ?? 'noStatus'} ${runError.signal ?? 'noSignal'}`);
            }
            this.console.debug('DEBUG | npm-ls exited with errors that are to be ignored.');
            npmLsReturns = runError.stdout ?? Buffer.alloc(0);
        }
        try {
            return JSON.parse(npmLsReturns.toString());
        }
        catch (jsonParseError) {
            throw new Error('failed to parse npm-ls response', { cause: jsonParseError });
        }
    }
    buildFromNpmLs(data) {
        this.console.info('INFO  | build BOM ...');
        const rootComponent = this.makeComponent(data, this.metaComponentType) ||
            new DummyComponent(this.metaComponentType, 'RootComponent');
        const allComponents = new Map([[data.path, rootComponent]]);
        this.gatherDependencies(allComponents, data, rootComponent.dependencies);
        this.finalizePathProperties(data.path, allComponents.values());
        const bom = new cyclonedx_library_1.Models.Bom();
        bom.metadata.component = rootComponent;
        const thisTool = (0, thisTool_1.makeThisTool)(this.toolBuilder);
        if (thisTool !== undefined) {
            bom.metadata.tools.add(thisTool);
        }
        if (!this.reproducible) {
            bom.serialNumber = this.makeRandomSerialNumber();
            bom.metadata.timestamp = new Date();
        }
        bom.components = this.nestComponents(new Map(Array.from(allComponents.entries()).filter(([, c]) => c !== rootComponent)), this.treeBuilder.fromPaths(new Set(allComponents.keys()), data.path[0] === '/' ? '/' : '\\'));
        bom.components.forEach(c => this.adjustNestedBomRefs(c, ''));
        rootComponent.components.clear();
        if (this.flattenComponents) {
            for (const component of allComponents.values()) {
                component.components.clear();
                if (component !== rootComponent) {
                    bom.components.add(component);
                }
            }
        }
        return bom;
    }
    adjustNestedBomRefs(component, pref) {
        if (component.bomRef.value === undefined) {
            return;
        }
        component.bomRef.value = pref + component.bomRef.value;
        const fill = component.bomRef.value + '|';
        component.components.forEach(c => this.adjustNestedBomRefs(c, fill));
    }
    nestComponents(allComponents, tree) {
        const children = new cyclonedx_library_1.Models.ComponentRepository();
        for (const [p, pTree] of tree) {
            const component = allComponents.get(p);
            const components = this.nestComponents(allComponents, pTree);
            if (component === undefined) {
                components.forEach(c => children.add(c));
            }
            else {
                component.components = components;
                children.add(component);
            }
        }
        return children;
    }
    gatherDependencies(allComponents, data, directDepRefs) {
        for (const [depName, depData] of Object.entries(data.dependencies ?? {})) {
            if (depData === null || typeof depData !== 'object') {
                continue;
            }
            if (typeof depData.path !== 'string') {
                continue;
            }
            let dep = allComponents.get(depData.path);
            if (dep === undefined) {
                const _dep = this.makeComponent(this.packageLockOnly
                    ? depData
                    : this.enhancedPackageData(depData));
                if (_dep === false) {
                    continue;
                }
                dep = _dep ??
                    new DummyComponent(cyclonedx_library_1.Enums.ComponentType.Library, `InterferedDependency.${depName}`);
                if (dep instanceof DummyComponent) {
                    this.console.warn('WARN  | InterferedDependency $j', dep.name);
                }
                allComponents.set(depData.path, dep);
            }
            directDepRefs.add(dep.bomRef);
            this.gatherDependencies(allComponents, depData, dep.dependencies);
        }
    }
    enhancedPackageData(data) {
        try {
            return Object.assign(require(`${data.path}/package.json`), data);
        }
        catch {
            return data;
        }
    }
    makeComponent(data, type) {
        const isDev = (data.dev ?? data._development) === true;
        if (isDev && this.omitDependencyTypes.has('dev')) {
            this.console.debug('DEBUG | omit dev component: %j %j', data.name, data._id);
            return false;
        }
        const component = this.componentBuilder.makeComponent(data, type);
        if (component === undefined) {
            this.console.debug('DEBUG | skip broken component: %j %j', data.name, data._id);
            return undefined;
        }
        if (typeof data.path === 'string') {
            component.properties.add(new cyclonedx_library_1.Models.Property(properties_1.PropertyNames.PackageInstallPath, data.path));
        }
        if (isDev) {
            component.properties.add(new cyclonedx_library_1.Models.Property(properties_1.PropertyNames.PackageDevelopment, properties_1.PropertyValueBool.True));
        }
        if (data.extraneous === true) {
            component.properties.add(new cyclonedx_library_1.Models.Property(properties_1.PropertyNames.PackageExtraneous, properties_1.PropertyValueBool.True));
        }
        if (data.private === true) {
            component.properties.add(new cyclonedx_library_1.Models.Property(properties_1.PropertyNames.PackagePrivate, properties_1.PropertyValueBool.True));
        }
        if ((data.inBundle ?? data._inBundle) === true) {
            component.properties.add(new cyclonedx_library_1.Models.Property(properties_1.PropertyNames.PackageBundled, properties_1.PropertyValueBool.True));
        }
        const resolved = data.resolved ?? data._resolved;
        if (typeof resolved === 'string' && !this.resolvedRE_ignore.test(resolved)) {
            component.externalReferences.add(new cyclonedx_library_1.Models.ExternalReference(resolved, cyclonedx_library_1.Enums.ExternalReferenceType.Distribution, { comment: 'as detected from npm-ls property "resolved"' }));
        }
        const integrity = data.integrity ?? data._integrity;
        if (typeof integrity === 'string') {
            const hashSha512Match = this.hashRE_sha512_base64.exec(integrity) ?? [];
            if (hashSha512Match?.length === 2) {
                component.hashes.set(cyclonedx_library_1.Enums.HashAlgorithm['SHA-512'], Buffer.from(hashSha512Match[1], 'base64').toString('hex'));
            }
        }
        component.purl = this.makePurl(component);
        component.bomRef.value = (typeof data._id === 'string' ? data._id : undefined) ||
            `${component.group || '-'}/${component.name}@${component.version || '-'}`;
        return component;
    }
    makePurl(component) {
        const purl = this.purlFactory.makeFromComponent(component, this.reproducible);
        if (purl === undefined) {
            return undefined;
        }
        if (this.shortPURLs) {
            purl.qualifiers = undefined;
            purl.subpath = undefined;
        }
        return purl;
    }
    finalizePathProperties(rootPath, components) {
        if (typeof rootPath !== 'string' || rootPath === '') {
            return;
        }
        const [relativePath, dirSep] = rootPath[0] === '/'
            ? [path.posix.relative, '/']
            : [path.win32.relative, '\\'];
        for (const component of components) {
            for (const property of component.properties) {
                if (property.name !== properties_1.PropertyNames.PackageInstallPath) {
                    continue;
                }
                if (property.value === '') {
                    component.properties.delete(property);
                    continue;
                }
                property.value = relativePath(rootPath, property.value).replace(dirSep, '/');
            }
        }
    }
    makeRandomSerialNumber() {
        const b = [
            Math.round(Math.random() * 0xFFFF),
            Math.round(Math.random() * 0xFFFF),
            Math.round(Math.random() * 0xFFFF),
            Math.round(Math.random() * 0x0FFF) | 0x4000,
            Math.round(Math.random() * 0x3FFF) | 0x8000,
            Math.round(Math.random() * 0xFFFF),
            Math.round(Math.random() * 0xFFFF),
            Math.round(Math.random() * 0xFFFF)
        ];
        const s = b.map(n => n.toString(16).padStart(4, '0'));
        return `urn:uuid:${s[0]}${s[1]}-${s[2]}-${s[3]}-${s[4]}-${s[5]}${s[6]}${s[7]}`;
    }
}
exports.BomBuilder = BomBuilder;
class DummyComponent extends cyclonedx_library_1.Models.Component {
    constructor(type, name) {
        super(type, `DummyComponent.${name}`, {
            bomRef: `DummyComponent.${name}`,
            description: `This is a dummy component "${name}" that fills the gap where the actual built failed.`
        });
    }
}
class TreeBuilder {
    fromPaths(paths, dirSeparator) {
        const tree = new Map(Array.from(paths, p => [p + dirSeparator, new Map()]));
        this.nestPT(tree);
        this.renderPR(tree, '');
        return tree;
    }
    renderPR(tree, pref) {
        for (const [p, pTree] of [...tree.entries()]) {
            tree.delete(p);
            const pFull = pref + p;
            this.renderPR(pTree, pFull);
            tree.set(pFull.slice(undefined, -1), pTree);
        }
    }
    nestPT(tree) {
        if (tree.size < 2) {
            return;
        }
        for (const a of tree.keys()) {
            for (const [b, bTree] of tree) {
                if (a === b) {
                    continue;
                }
                if (b.startsWith(a)) {
                    tree.get(a).set(b.slice(a.length), bTree);
                    tree.delete(b);
                }
            }
        }
        for (const c of tree.values()) {
            this.nestPT(c);
        }
    }
}
exports.TreeBuilder = TreeBuilder;
//# sourceMappingURL=builders.js.map